// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: products.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countProducts = `-- name: CountProducts :one
SELECT COUNT(*) FROM products
`

func (q *Queries) CountProducts(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countProducts)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countProductsByAreaAndSearch = `-- name: CountProductsByAreaAndSearch :one
SELECT COUNT(*)
FROM products p
WHERE p.area_id = $1
  AND (p.code ILIKE '%' || $2::text || '%'
   OR p.description ILIKE '%' || $2::text || '%'
   OR p.sap_code ILIKE '%' || $2::text || '%'
   OR p.manufacturer_code ILIKE '%' || $2::text || '%'
   OR p.lifecycle_status ILIKE '%' || $2::text || '%')
`

type CountProductsByAreaAndSearchParams struct {
	AreaID pgtype.UUID `json:"area_id"`
	Search string      `json:"search"`
}

func (q *Queries) CountProductsByAreaAndSearch(ctx context.Context, arg CountProductsByAreaAndSearchParams) (int64, error) {
	row := q.db.QueryRow(ctx, countProductsByAreaAndSearch, arg.AreaID, arg.Search)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countProductsByLifecycleStatus = `-- name: CountProductsByLifecycleStatus :one
SELECT
    COUNT(*) FILTER (WHERE lifecycle_status = 'Active Product') AS active_count,
    COUNT(*) FILTER (
        WHERE lifecycle_status IN (
            'Prod. Cancellation',
            'End Prod.Lifecycl.',
            'Prod. Discont.'
        )
    ) AS discontinued_count,
    COUNT(*) FILTER (WHERE lifecycle_status = 'Phase Out Announce') AS phase_out_count
FROM (
    SELECT DISTINCT code, lifecycle_status
    FROM products
) p
`

type CountProductsByLifecycleStatusRow struct {
	ActiveCount       int64 `json:"active_count"`
	DiscontinuedCount int64 `json:"discontinued_count"`
	PhaseOutCount     int64 `json:"phase_out_count"`
}

func (q *Queries) CountProductsByLifecycleStatus(ctx context.Context) (CountProductsByLifecycleStatusRow, error) {
	row := q.db.QueryRow(ctx, countProductsByLifecycleStatus)
	var i CountProductsByLifecycleStatusRow
	err := row.Scan(&i.ActiveCount, &i.DiscontinuedCount, &i.PhaseOutCount)
	return i, err
}

const countProductsBySearch = `-- name: CountProductsBySearch :one
SELECT COUNT(*)
FROM products p
WHERE p.code ILIKE '%' || $1::text || '%'
   OR p.description ILIKE '%' || $1::text || '%'
   OR p.sap_code ILIKE '%' || $1::text || '%'
   OR p.manufacturer_code ILIKE '%' || $1::text || '%'
   OR p.lifecycle_status ILIKE '%' || $1::text || '%'
`

func (q *Queries) CountProductsBySearch(ctx context.Context, search string) (int64, error) {
	row := q.db.QueryRow(ctx, countProductsBySearch, search)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countProductsInArea = `-- name: CountProductsInArea :one
SELECT COUNT(*) FROM products WHERE area_id = $1
`

func (q *Queries) CountProductsInArea(ctx context.Context, areaID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countProductsInArea, areaID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUniqueProducts = `-- name: CountUniqueProducts :one
SELECT COUNT(DISTINCT code) FROM products
`

func (q *Queries) CountUniqueProducts(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countUniqueProducts)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUniqueProductsByAreaAndSearch = `-- name: CountUniqueProductsByAreaAndSearch :one
SELECT COUNT(DISTINCT p.code)
FROM products p
WHERE p.area_id = $1
  AND (p.code ILIKE '%' || $2::text || '%'
   OR p.description ILIKE '%' || $2::text || '%'
   OR p.sap_code ILIKE '%' || $2::text || '%'
   OR p.manufacturer_code ILIKE '%' || $2::text || '%'
   OR p.lifecycle_status ILIKE '%' || $2::text || '%')
`

type CountUniqueProductsByAreaAndSearchParams struct {
	AreaID pgtype.UUID `json:"area_id"`
	Search string      `json:"search"`
}

func (q *Queries) CountUniqueProductsByAreaAndSearch(ctx context.Context, arg CountUniqueProductsByAreaAndSearchParams) (int64, error) {
	row := q.db.QueryRow(ctx, countUniqueProductsByAreaAndSearch, arg.AreaID, arg.Search)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUniqueProductsBySearch = `-- name: CountUniqueProductsBySearch :one
SELECT COUNT(DISTINCT code)
FROM products p
WHERE p.code ILIKE '%' || $1::text || '%'
   OR p.description ILIKE '%' || $1::text || '%'
   OR p.sap_code ILIKE '%' || $1::text || '%'
   OR p.manufacturer_code ILIKE '%' || $1::text || '%'
   OR p.lifecycle_status ILIKE '%' || $1::text || '%'
`

func (q *Queries) CountUniqueProductsBySearch(ctx context.Context, search string) (int64, error) {
	row := q.db.QueryRow(ctx, countUniqueProductsBySearch, search)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUniqueProductsInArea = `-- name: CountUniqueProductsInArea :one
SELECT COUNT(DISTINCT code) FROM products WHERE area_id = $1
`

func (q *Queries) CountUniqueProductsInArea(ctx context.Context, areaID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countUniqueProductsInArea, areaID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (
    code, url, area_id, description, manufacturer_code,
    quantity, sap_code, observations, min_quantity, max_quantity, inventory_status
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING id, code, url, area_id, description, manufacturer_code, quantity, replacement_url, sap_code, observations, min_quantity, max_quantity, inventory_status, lifecycle_status, created_at
`

type CreateProductParams struct {
	Code             string      `json:"code"`
	Url              string      `json:"url"`
	AreaID           pgtype.UUID `json:"area_id"`
	Description      pgtype.Text `json:"description"`
	ManufacturerCode pgtype.Text `json:"manufacturer_code"`
	Quantity         pgtype.Int4 `json:"quantity"`
	SapCode          pgtype.Text `json:"sap_code"`
	Observations     pgtype.Text `json:"observations"`
	MinQuantity      pgtype.Int4 `json:"min_quantity"`
	MaxQuantity      pgtype.Int4 `json:"max_quantity"`
	InventoryStatus  pgtype.Text `json:"inventory_status"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, createProduct,
		arg.Code,
		arg.Url,
		arg.AreaID,
		arg.Description,
		arg.ManufacturerCode,
		arg.Quantity,
		arg.SapCode,
		arg.Observations,
		arg.MinQuantity,
		arg.MaxQuantity,
		arg.InventoryStatus,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Url,
		&i.AreaID,
		&i.Description,
		&i.ManufacturerCode,
		&i.Quantity,
		&i.ReplacementUrl,
		&i.SapCode,
		&i.Observations,
		&i.MinQuantity,
		&i.MaxQuantity,
		&i.InventoryStatus,
		&i.LifecycleStatus,
		&i.CreatedAt,
	)
	return i, err
}

const deleteProduct = `-- name: DeleteProduct :exec
DELETE FROM products WHERE id = $1
`

func (q *Queries) DeleteProduct(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteProduct, id)
	return err
}

const findProductByCode = `-- name: FindProductByCode :one
SELECT p.id, p.code, p.url, p.area_id, p.description, p.manufacturer_code, p.quantity, p.replacement_url, p.sap_code, p.observations, p.min_quantity, p.max_quantity, p.inventory_status, p.lifecycle_status, p.created_at, a.name as area_name
FROM products p
LEFT JOIN areas a ON p.area_id = a.id
WHERE p.code = $1
`

type FindProductByCodeRow struct {
	ID               pgtype.UUID      `json:"id"`
	Code             string           `json:"code"`
	Url              string           `json:"url"`
	AreaID           pgtype.UUID      `json:"area_id"`
	Description      pgtype.Text      `json:"description"`
	ManufacturerCode pgtype.Text      `json:"manufacturer_code"`
	Quantity         pgtype.Int4      `json:"quantity"`
	ReplacementUrl   pgtype.Text      `json:"replacement_url"`
	SapCode          pgtype.Text      `json:"sap_code"`
	Observations     pgtype.Text      `json:"observations"`
	MinQuantity      pgtype.Int4      `json:"min_quantity"`
	MaxQuantity      pgtype.Int4      `json:"max_quantity"`
	InventoryStatus  pgtype.Text      `json:"inventory_status"`
	LifecycleStatus  pgtype.Text      `json:"lifecycle_status"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
	AreaName         pgtype.Text      `json:"area_name"`
}

func (q *Queries) FindProductByCode(ctx context.Context, code string) (FindProductByCodeRow, error) {
	row := q.db.QueryRow(ctx, findProductByCode, code)
	var i FindProductByCodeRow
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Url,
		&i.AreaID,
		&i.Description,
		&i.ManufacturerCode,
		&i.Quantity,
		&i.ReplacementUrl,
		&i.SapCode,
		&i.Observations,
		&i.MinQuantity,
		&i.MaxQuantity,
		&i.InventoryStatus,
		&i.LifecycleStatus,
		&i.CreatedAt,
		&i.AreaName,
	)
	return i, err
}

const findProductByCodeAndArea = `-- name: FindProductByCodeAndArea :one
SELECT p.id, p.code, p.url, p.area_id, p.description, p.manufacturer_code, p.quantity, p.replacement_url, p.sap_code, p.observations, p.min_quantity, p.max_quantity, p.inventory_status, p.lifecycle_status, p.created_at, a.name as area_name
FROM products p
LEFT JOIN areas a ON p.area_id = a.id
WHERE p.code = $1 AND (p.area_id = $2 OR ($2 IS NULL AND p.area_id IS NULL))
`

type FindProductByCodeAndAreaParams struct {
	Code   string      `json:"code"`
	AreaID pgtype.UUID `json:"area_id"`
}

type FindProductByCodeAndAreaRow struct {
	ID               pgtype.UUID      `json:"id"`
	Code             string           `json:"code"`
	Url              string           `json:"url"`
	AreaID           pgtype.UUID      `json:"area_id"`
	Description      pgtype.Text      `json:"description"`
	ManufacturerCode pgtype.Text      `json:"manufacturer_code"`
	Quantity         pgtype.Int4      `json:"quantity"`
	ReplacementUrl   pgtype.Text      `json:"replacement_url"`
	SapCode          pgtype.Text      `json:"sap_code"`
	Observations     pgtype.Text      `json:"observations"`
	MinQuantity      pgtype.Int4      `json:"min_quantity"`
	MaxQuantity      pgtype.Int4      `json:"max_quantity"`
	InventoryStatus  pgtype.Text      `json:"inventory_status"`
	LifecycleStatus  pgtype.Text      `json:"lifecycle_status"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
	AreaName         pgtype.Text      `json:"area_name"`
}

func (q *Queries) FindProductByCodeAndArea(ctx context.Context, arg FindProductByCodeAndAreaParams) (FindProductByCodeAndAreaRow, error) {
	row := q.db.QueryRow(ctx, findProductByCodeAndArea, arg.Code, arg.AreaID)
	var i FindProductByCodeAndAreaRow
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Url,
		&i.AreaID,
		&i.Description,
		&i.ManufacturerCode,
		&i.Quantity,
		&i.ReplacementUrl,
		&i.SapCode,
		&i.Observations,
		&i.MinQuantity,
		&i.MaxQuantity,
		&i.InventoryStatus,
		&i.LifecycleStatus,
		&i.CreatedAt,
		&i.AreaName,
	)
	return i, err
}

const findProductByID = `-- name: FindProductByID :one
SELECT p.id, p.code, p.url, p.area_id, p.description, p.manufacturer_code, p.quantity, p.replacement_url, p.sap_code, p.observations, p.min_quantity, p.max_quantity, p.inventory_status, p.lifecycle_status, p.created_at, a.name as area_name
FROM products p
LEFT JOIN areas a ON p.area_id = a.id
WHERE p.id = $1
`

type FindProductByIDRow struct {
	ID               pgtype.UUID      `json:"id"`
	Code             string           `json:"code"`
	Url              string           `json:"url"`
	AreaID           pgtype.UUID      `json:"area_id"`
	Description      pgtype.Text      `json:"description"`
	ManufacturerCode pgtype.Text      `json:"manufacturer_code"`
	Quantity         pgtype.Int4      `json:"quantity"`
	ReplacementUrl   pgtype.Text      `json:"replacement_url"`
	SapCode          pgtype.Text      `json:"sap_code"`
	Observations     pgtype.Text      `json:"observations"`
	MinQuantity      pgtype.Int4      `json:"min_quantity"`
	MaxQuantity      pgtype.Int4      `json:"max_quantity"`
	InventoryStatus  pgtype.Text      `json:"inventory_status"`
	LifecycleStatus  pgtype.Text      `json:"lifecycle_status"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
	AreaName         pgtype.Text      `json:"area_name"`
}

func (q *Queries) FindProductByID(ctx context.Context, id pgtype.UUID) (FindProductByIDRow, error) {
	row := q.db.QueryRow(ctx, findProductByID, id)
	var i FindProductByIDRow
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Url,
		&i.AreaID,
		&i.Description,
		&i.ManufacturerCode,
		&i.Quantity,
		&i.ReplacementUrl,
		&i.SapCode,
		&i.Observations,
		&i.MinQuantity,
		&i.MaxQuantity,
		&i.InventoryStatus,
		&i.LifecycleStatus,
		&i.CreatedAt,
		&i.AreaName,
	)
	return i, err
}

const listAllProductsToCollect = `-- name: ListAllProductsToCollect :many
SELECT p.id, p.code, p.url, p.created_at
FROM products p
ORDER BY p.created_at ASC
`

type ListAllProductsToCollectRow struct {
	ID        pgtype.UUID      `json:"id"`
	Code      string           `json:"code"`
	Url       string           `json:"url"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) ListAllProductsToCollect(ctx context.Context) ([]ListAllProductsToCollectRow, error) {
	rows, err := q.db.Query(ctx, listAllProductsToCollect)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllProductsToCollectRow
	for rows.Next() {
		var i ListAllProductsToCollectRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Url,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProducts = `-- name: ListProducts :many
SELECT id, code, url, area_id, description, manufacturer_code, quantity, replacement_url, sap_code, observations, min_quantity, max_quantity, inventory_status, lifecycle_status, created_at, area_name FROM (
    SELECT p.id, p.code, p.url, p.area_id, p.description, p.manufacturer_code, p.quantity, p.replacement_url, p.sap_code, p.observations, p.min_quantity, p.max_quantity, p.inventory_status, p.lifecycle_status, p.created_at, a.name as area_name
    FROM products p
    LEFT JOIN areas a ON p.area_id = a.id
    ORDER BY p.code, p.created_at DESC
) sub
ORDER BY lifecycle_status DESC, created_at DESC
`

type ListProductsRow struct {
	ID               pgtype.UUID      `json:"id"`
	Code             string           `json:"code"`
	Url              string           `json:"url"`
	AreaID           pgtype.UUID      `json:"area_id"`
	Description      pgtype.Text      `json:"description"`
	ManufacturerCode pgtype.Text      `json:"manufacturer_code"`
	Quantity         pgtype.Int4      `json:"quantity"`
	ReplacementUrl   pgtype.Text      `json:"replacement_url"`
	SapCode          pgtype.Text      `json:"sap_code"`
	Observations     pgtype.Text      `json:"observations"`
	MinQuantity      pgtype.Int4      `json:"min_quantity"`
	MaxQuantity      pgtype.Int4      `json:"max_quantity"`
	InventoryStatus  pgtype.Text      `json:"inventory_status"`
	LifecycleStatus  pgtype.Text      `json:"lifecycle_status"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
	AreaName         pgtype.Text      `json:"area_name"`
}

func (q *Queries) ListProducts(ctx context.Context) ([]ListProductsRow, error) {
	rows, err := q.db.Query(ctx, listProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductsRow
	for rows.Next() {
		var i ListProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Url,
			&i.AreaID,
			&i.Description,
			&i.ManufacturerCode,
			&i.Quantity,
			&i.ReplacementUrl,
			&i.SapCode,
			&i.Observations,
			&i.MinQuantity,
			&i.MaxQuantity,
			&i.InventoryStatus,
			&i.LifecycleStatus,
			&i.CreatedAt,
			&i.AreaName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsByArea = `-- name: ListProductsByArea :many
SELECT p.id, p.code, p.url, p.area_id, p.description, p.manufacturer_code, p.quantity, p.replacement_url, p.sap_code, p.observations, p.min_quantity, p.max_quantity, p.inventory_status, p.lifecycle_status, p.created_at, a.name as area_name
FROM products p
LEFT JOIN areas a ON p.area_id = a.id
WHERE p.area_id = $1
ORDER BY p.lifecycle_status DESC, p.created_at DESC
`

type ListProductsByAreaRow struct {
	ID               pgtype.UUID      `json:"id"`
	Code             string           `json:"code"`
	Url              string           `json:"url"`
	AreaID           pgtype.UUID      `json:"area_id"`
	Description      pgtype.Text      `json:"description"`
	ManufacturerCode pgtype.Text      `json:"manufacturer_code"`
	Quantity         pgtype.Int4      `json:"quantity"`
	ReplacementUrl   pgtype.Text      `json:"replacement_url"`
	SapCode          pgtype.Text      `json:"sap_code"`
	Observations     pgtype.Text      `json:"observations"`
	MinQuantity      pgtype.Int4      `json:"min_quantity"`
	MaxQuantity      pgtype.Int4      `json:"max_quantity"`
	InventoryStatus  pgtype.Text      `json:"inventory_status"`
	LifecycleStatus  pgtype.Text      `json:"lifecycle_status"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
	AreaName         pgtype.Text      `json:"area_name"`
}

func (q *Queries) ListProductsByArea(ctx context.Context, areaID pgtype.UUID) ([]ListProductsByAreaRow, error) {
	rows, err := q.db.Query(ctx, listProductsByArea, areaID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductsByAreaRow
	for rows.Next() {
		var i ListProductsByAreaRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Url,
			&i.AreaID,
			&i.Description,
			&i.ManufacturerCode,
			&i.Quantity,
			&i.ReplacementUrl,
			&i.SapCode,
			&i.Observations,
			&i.MinQuantity,
			&i.MaxQuantity,
			&i.InventoryStatus,
			&i.LifecycleStatus,
			&i.CreatedAt,
			&i.AreaName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsByAreaPaginated = `-- name: ListProductsByAreaPaginated :many
SELECT p.id, p.code, p.url, p.area_id, p.description, p.manufacturer_code, p.quantity, p.replacement_url, p.sap_code, p.observations, p.min_quantity, p.max_quantity, p.inventory_status, p.lifecycle_status, p.created_at, a.name as area_name
FROM products p
LEFT JOIN areas a ON p.area_id = a.id
WHERE p.area_id = $1
ORDER BY p.lifecycle_status DESC, p.created_at DESC
LIMIT $2 OFFSET $3
`

type ListProductsByAreaPaginatedParams struct {
	AreaID pgtype.UUID `json:"area_id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

type ListProductsByAreaPaginatedRow struct {
	ID               pgtype.UUID      `json:"id"`
	Code             string           `json:"code"`
	Url              string           `json:"url"`
	AreaID           pgtype.UUID      `json:"area_id"`
	Description      pgtype.Text      `json:"description"`
	ManufacturerCode pgtype.Text      `json:"manufacturer_code"`
	Quantity         pgtype.Int4      `json:"quantity"`
	ReplacementUrl   pgtype.Text      `json:"replacement_url"`
	SapCode          pgtype.Text      `json:"sap_code"`
	Observations     pgtype.Text      `json:"observations"`
	MinQuantity      pgtype.Int4      `json:"min_quantity"`
	MaxQuantity      pgtype.Int4      `json:"max_quantity"`
	InventoryStatus  pgtype.Text      `json:"inventory_status"`
	LifecycleStatus  pgtype.Text      `json:"lifecycle_status"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
	AreaName         pgtype.Text      `json:"area_name"`
}

func (q *Queries) ListProductsByAreaPaginated(ctx context.Context, arg ListProductsByAreaPaginatedParams) ([]ListProductsByAreaPaginatedRow, error) {
	rows, err := q.db.Query(ctx, listProductsByAreaPaginated, arg.AreaID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductsByAreaPaginatedRow
	for rows.Next() {
		var i ListProductsByAreaPaginatedRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Url,
			&i.AreaID,
			&i.Description,
			&i.ManufacturerCode,
			&i.Quantity,
			&i.ReplacementUrl,
			&i.SapCode,
			&i.Observations,
			&i.MinQuantity,
			&i.MaxQuantity,
			&i.InventoryStatus,
			&i.LifecycleStatus,
			&i.CreatedAt,
			&i.AreaName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsPaginated = `-- name: ListProductsPaginated :many
SELECT id, code, url, area_id, description, manufacturer_code, quantity, replacement_url, sap_code, observations, min_quantity, max_quantity, inventory_status, lifecycle_status, created_at, area_name FROM (
    SELECT p.id, p.code, p.url, p.area_id, p.description, p.manufacturer_code, p.quantity, p.replacement_url, p.sap_code, p.observations, p.min_quantity, p.max_quantity, p.inventory_status, p.lifecycle_status, p.created_at, a.name as area_name
    FROM products p
    LEFT JOIN areas a ON p.area_id = a.id
    ORDER BY p.code, p.created_at DESC
) sub
ORDER BY lifecycle_status DESC, created_at DESC
LIMIT $1 OFFSET $2
`

type ListProductsPaginatedParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListProductsPaginatedRow struct {
	ID               pgtype.UUID      `json:"id"`
	Code             string           `json:"code"`
	Url              string           `json:"url"`
	AreaID           pgtype.UUID      `json:"area_id"`
	Description      pgtype.Text      `json:"description"`
	ManufacturerCode pgtype.Text      `json:"manufacturer_code"`
	Quantity         pgtype.Int4      `json:"quantity"`
	ReplacementUrl   pgtype.Text      `json:"replacement_url"`
	SapCode          pgtype.Text      `json:"sap_code"`
	Observations     pgtype.Text      `json:"observations"`
	MinQuantity      pgtype.Int4      `json:"min_quantity"`
	MaxQuantity      pgtype.Int4      `json:"max_quantity"`
	InventoryStatus  pgtype.Text      `json:"inventory_status"`
	LifecycleStatus  pgtype.Text      `json:"lifecycle_status"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
	AreaName         pgtype.Text      `json:"area_name"`
}

func (q *Queries) ListProductsPaginated(ctx context.Context, arg ListProductsPaginatedParams) ([]ListProductsPaginatedRow, error) {
	rows, err := q.db.Query(ctx, listProductsPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductsPaginatedRow
	for rows.Next() {
		var i ListProductsPaginatedRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Url,
			&i.AreaID,
			&i.Description,
			&i.ManufacturerCode,
			&i.Quantity,
			&i.ReplacementUrl,
			&i.SapCode,
			&i.Observations,
			&i.MinQuantity,
			&i.MaxQuantity,
			&i.InventoryStatus,
			&i.LifecycleStatus,
			&i.CreatedAt,
			&i.AreaName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUniqueProductCodesToCollect = `-- name: ListUniqueProductCodesToCollect :many
SELECT DISTINCT ON (p.code) p.id, p.code, p.url
FROM products p
ORDER BY p.code, p.created_at ASC
`

type ListUniqueProductCodesToCollectRow struct {
	ID   pgtype.UUID `json:"id"`
	Code string      `json:"code"`
	Url  string      `json:"url"`
}

func (q *Queries) ListUniqueProductCodesToCollect(ctx context.Context) ([]ListUniqueProductCodesToCollectRow, error) {
	rows, err := q.db.Query(ctx, listUniqueProductCodesToCollect)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUniqueProductCodesToCollectRow
	for rows.Next() {
		var i ListUniqueProductCodesToCollectRow
		if err := rows.Scan(&i.ID, &i.Code, &i.Url); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUniqueProductsByAreaPaginated = `-- name: ListUniqueProductsByAreaPaginated :many
WITH product_aggregates AS (
    SELECT
        p.code,
        MIN(p.description) as description,
        MIN(p.lifecycle_status) as lifecycle_status,
        MIN(p.replacement_url) as replacement_url,
        MIN(p.url) as url,
        MIN(p.manufacturer_code) as manufacturer_code,
        MIN(p.sap_code) as sap_code,
        SUM(COALESCE(p.quantity, 0))::INTEGER as total_quantity,
        MIN(p.created_at) as created_at,
        json_agg(
            json_build_object(
                'area_id', p2.area_id,
                'area_name', a.name,
                'quantity', COALESCE(p2.quantity, 0)
            ) ORDER BY a.name
        ) FILTER (WHERE p2.area_id IS NOT NULL) as quantity_by_area
    FROM products p
    INNER JOIN products p2 ON p.code = p2.code
    LEFT JOIN areas a ON p2.area_id = a.id
    WHERE p.area_id = $3
    GROUP BY p.code
)
SELECT code, description, lifecycle_status, replacement_url, url, manufacturer_code, sap_code, total_quantity, created_at, quantity_by_area FROM product_aggregates
ORDER BY lifecycle_status DESC, created_at DESC
LIMIT $2 OFFSET $1
`

type ListUniqueProductsByAreaPaginatedParams struct {
	Offset int32       `json:"offset"`
	Limit  int32       `json:"limit"`
	AreaID pgtype.UUID `json:"area_id"`
}

type ListUniqueProductsByAreaPaginatedRow struct {
	Code             string      `json:"code"`
	Description      interface{} `json:"description"`
	LifecycleStatus  interface{} `json:"lifecycle_status"`
	ReplacementUrl   interface{} `json:"replacement_url"`
	Url              interface{} `json:"url"`
	ManufacturerCode interface{} `json:"manufacturer_code"`
	SapCode          interface{} `json:"sap_code"`
	TotalQuantity    int32       `json:"total_quantity"`
	CreatedAt        interface{} `json:"created_at"`
	QuantityByArea   []byte      `json:"quantity_by_area"`
}

func (q *Queries) ListUniqueProductsByAreaPaginated(ctx context.Context, arg ListUniqueProductsByAreaPaginatedParams) ([]ListUniqueProductsByAreaPaginatedRow, error) {
	rows, err := q.db.Query(ctx, listUniqueProductsByAreaPaginated, arg.Offset, arg.Limit, arg.AreaID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUniqueProductsByAreaPaginatedRow
	for rows.Next() {
		var i ListUniqueProductsByAreaPaginatedRow
		if err := rows.Scan(
			&i.Code,
			&i.Description,
			&i.LifecycleStatus,
			&i.ReplacementUrl,
			&i.Url,
			&i.ManufacturerCode,
			&i.SapCode,
			&i.TotalQuantity,
			&i.CreatedAt,
			&i.QuantityByArea,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUniqueProductsPaginated = `-- name: ListUniqueProductsPaginated :many
WITH product_aggregates AS (
    SELECT
        p.code,
        MIN(p.description) as description,
        MIN(p.lifecycle_status) as lifecycle_status,
        MIN(p.replacement_url) as replacement_url,
        MIN(p.url) as url,
        MIN(p.manufacturer_code) as manufacturer_code,
        MIN(p.sap_code) as sap_code,
        SUM(COALESCE(p.quantity, 0))::INTEGER as total_quantity,
        MIN(p.created_at) as created_at,
        json_agg(
            json_build_object(
                'area_id', p.area_id,
                'area_name', a.name,
                'quantity', COALESCE(p.quantity, 0)
            ) ORDER BY a.name
        ) FILTER (WHERE p.area_id IS NOT NULL) as quantity_by_area
    FROM products p
    LEFT JOIN areas a ON p.area_id = a.id
    GROUP BY p.code
)
SELECT code, description, lifecycle_status, replacement_url, url, manufacturer_code, sap_code, total_quantity, created_at, quantity_by_area FROM product_aggregates
ORDER BY lifecycle_status DESC, created_at DESC
LIMIT $1 OFFSET $2
`

type ListUniqueProductsPaginatedParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListUniqueProductsPaginatedRow struct {
	Code             string      `json:"code"`
	Description      interface{} `json:"description"`
	LifecycleStatus  interface{} `json:"lifecycle_status"`
	ReplacementUrl   interface{} `json:"replacement_url"`
	Url              interface{} `json:"url"`
	ManufacturerCode interface{} `json:"manufacturer_code"`
	SapCode          interface{} `json:"sap_code"`
	TotalQuantity    int32       `json:"total_quantity"`
	CreatedAt        interface{} `json:"created_at"`
	QuantityByArea   []byte      `json:"quantity_by_area"`
}

func (q *Queries) ListUniqueProductsPaginated(ctx context.Context, arg ListUniqueProductsPaginatedParams) ([]ListUniqueProductsPaginatedRow, error) {
	rows, err := q.db.Query(ctx, listUniqueProductsPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUniqueProductsPaginatedRow
	for rows.Next() {
		var i ListUniqueProductsPaginatedRow
		if err := rows.Scan(
			&i.Code,
			&i.Description,
			&i.LifecycleStatus,
			&i.ReplacementUrl,
			&i.Url,
			&i.ManufacturerCode,
			&i.SapCode,
			&i.TotalQuantity,
			&i.CreatedAt,
			&i.QuantityByArea,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchProducts = `-- name: SearchProducts :many
SELECT p.id, p.code, p.url, p.area_id, p.description, p.manufacturer_code, p.quantity, p.replacement_url, p.sap_code, p.observations, p.min_quantity, p.max_quantity, p.inventory_status, p.lifecycle_status, p.created_at, a.name as area_name
FROM products p
LEFT JOIN areas a ON p.area_id = a.id
WHERE p.code ILIKE '%' || $1::text || '%'
   OR p.description ILIKE '%' || $1::text || '%'
   OR p.sap_code ILIKE '%' || $1::text || '%'
   OR p.manufacturer_code ILIKE '%' || $1::text || '%'
   OR p.lifecycle_status ILIKE '%' || $1::text || '%'
ORDER BY p.lifecycle_status DESC, p.created_at DESC
LIMIT $3 OFFSET $2
`

type SearchProductsParams struct {
	Search string `json:"search"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

type SearchProductsRow struct {
	ID               pgtype.UUID      `json:"id"`
	Code             string           `json:"code"`
	Url              string           `json:"url"`
	AreaID           pgtype.UUID      `json:"area_id"`
	Description      pgtype.Text      `json:"description"`
	ManufacturerCode pgtype.Text      `json:"manufacturer_code"`
	Quantity         pgtype.Int4      `json:"quantity"`
	ReplacementUrl   pgtype.Text      `json:"replacement_url"`
	SapCode          pgtype.Text      `json:"sap_code"`
	Observations     pgtype.Text      `json:"observations"`
	MinQuantity      pgtype.Int4      `json:"min_quantity"`
	MaxQuantity      pgtype.Int4      `json:"max_quantity"`
	InventoryStatus  pgtype.Text      `json:"inventory_status"`
	LifecycleStatus  pgtype.Text      `json:"lifecycle_status"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
	AreaName         pgtype.Text      `json:"area_name"`
}

func (q *Queries) SearchProducts(ctx context.Context, arg SearchProductsParams) ([]SearchProductsRow, error) {
	rows, err := q.db.Query(ctx, searchProducts, arg.Search, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchProductsRow
	for rows.Next() {
		var i SearchProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Url,
			&i.AreaID,
			&i.Description,
			&i.ManufacturerCode,
			&i.Quantity,
			&i.ReplacementUrl,
			&i.SapCode,
			&i.Observations,
			&i.MinQuantity,
			&i.MaxQuantity,
			&i.InventoryStatus,
			&i.LifecycleStatus,
			&i.CreatedAt,
			&i.AreaName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchProductsByArea = `-- name: SearchProductsByArea :many
SELECT p.id, p.code, p.url, p.area_id, p.description, p.manufacturer_code, p.quantity, p.replacement_url, p.sap_code, p.observations, p.min_quantity, p.max_quantity, p.inventory_status, p.lifecycle_status, p.created_at, a.name as area_name
FROM products p
LEFT JOIN areas a ON p.area_id = a.id
WHERE p.area_id = $1
  AND (p.code ILIKE '%' || $2::text || '%'
   OR p.description ILIKE '%' || $2::text || '%'
   OR p.sap_code ILIKE '%' || $2::text || '%'
   OR p.manufacturer_code ILIKE '%' || $2::text || '%'
   OR p.lifecycle_status ILIKE '%' || $2::text || '%')
ORDER BY p.lifecycle_status DESC, p.created_at DESC
LIMIT $4 OFFSET $3
`

type SearchProductsByAreaParams struct {
	AreaID pgtype.UUID `json:"area_id"`
	Search string      `json:"search"`
	Offset int32       `json:"offset"`
	Limit  int32       `json:"limit"`
}

type SearchProductsByAreaRow struct {
	ID               pgtype.UUID      `json:"id"`
	Code             string           `json:"code"`
	Url              string           `json:"url"`
	AreaID           pgtype.UUID      `json:"area_id"`
	Description      pgtype.Text      `json:"description"`
	ManufacturerCode pgtype.Text      `json:"manufacturer_code"`
	Quantity         pgtype.Int4      `json:"quantity"`
	ReplacementUrl   pgtype.Text      `json:"replacement_url"`
	SapCode          pgtype.Text      `json:"sap_code"`
	Observations     pgtype.Text      `json:"observations"`
	MinQuantity      pgtype.Int4      `json:"min_quantity"`
	MaxQuantity      pgtype.Int4      `json:"max_quantity"`
	InventoryStatus  pgtype.Text      `json:"inventory_status"`
	LifecycleStatus  pgtype.Text      `json:"lifecycle_status"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
	AreaName         pgtype.Text      `json:"area_name"`
}

func (q *Queries) SearchProductsByArea(ctx context.Context, arg SearchProductsByAreaParams) ([]SearchProductsByAreaRow, error) {
	rows, err := q.db.Query(ctx, searchProductsByArea,
		arg.AreaID,
		arg.Search,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchProductsByAreaRow
	for rows.Next() {
		var i SearchProductsByAreaRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Url,
			&i.AreaID,
			&i.Description,
			&i.ManufacturerCode,
			&i.Quantity,
			&i.ReplacementUrl,
			&i.SapCode,
			&i.Observations,
			&i.MinQuantity,
			&i.MaxQuantity,
			&i.InventoryStatus,
			&i.LifecycleStatus,
			&i.CreatedAt,
			&i.AreaName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchUniqueProductsByAreaPaginated = `-- name: SearchUniqueProductsByAreaPaginated :many
WITH product_aggregates AS (
    SELECT
        p.code,
        MIN(p.description) as description,
        MIN(p.lifecycle_status) as lifecycle_status,
        MIN(p.replacement_url) as replacement_url,
        MIN(p.url) as url,
        MIN(p.manufacturer_code) as manufacturer_code,
        MIN(p.sap_code) as sap_code,
        SUM(COALESCE(p.quantity, 0))::INTEGER as total_quantity,
        MIN(p.created_at) as created_at,
        json_agg(
            json_build_object(
                'area_id', p2.area_id,
                'area_name', a.name,
                'quantity', COALESCE(p2.quantity, 0)
            ) ORDER BY a.name
        ) FILTER (WHERE p2.area_id IS NOT NULL) as quantity_by_area
    FROM products p
    INNER JOIN products p2 ON p.code = p2.code
    LEFT JOIN areas a ON p2.area_id = a.id
    WHERE p.area_id = $4
    GROUP BY p.code
)
SELECT code, description, lifecycle_status, replacement_url, url, manufacturer_code, sap_code, total_quantity, created_at, quantity_by_area FROM product_aggregates
WHERE code ILIKE '%' || $1::text || '%'
   OR description ILIKE '%' || $1::text || '%'
   OR sap_code ILIKE '%' || $1::text || '%'
   OR manufacturer_code ILIKE '%' || $1::text || '%'
   OR lifecycle_status ILIKE '%' || $1::text || '%'
ORDER BY lifecycle_status DESC, created_at DESC
LIMIT $3 OFFSET $2
`

type SearchUniqueProductsByAreaPaginatedParams struct {
	Search string      `json:"search"`
	Offset int32       `json:"offset"`
	Limit  int32       `json:"limit"`
	AreaID pgtype.UUID `json:"area_id"`
}

type SearchUniqueProductsByAreaPaginatedRow struct {
	Code             string      `json:"code"`
	Description      interface{} `json:"description"`
	LifecycleStatus  interface{} `json:"lifecycle_status"`
	ReplacementUrl   interface{} `json:"replacement_url"`
	Url              interface{} `json:"url"`
	ManufacturerCode interface{} `json:"manufacturer_code"`
	SapCode          interface{} `json:"sap_code"`
	TotalQuantity    int32       `json:"total_quantity"`
	CreatedAt        interface{} `json:"created_at"`
	QuantityByArea   []byte      `json:"quantity_by_area"`
}

func (q *Queries) SearchUniqueProductsByAreaPaginated(ctx context.Context, arg SearchUniqueProductsByAreaPaginatedParams) ([]SearchUniqueProductsByAreaPaginatedRow, error) {
	rows, err := q.db.Query(ctx, searchUniqueProductsByAreaPaginated,
		arg.Search,
		arg.Offset,
		arg.Limit,
		arg.AreaID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchUniqueProductsByAreaPaginatedRow
	for rows.Next() {
		var i SearchUniqueProductsByAreaPaginatedRow
		if err := rows.Scan(
			&i.Code,
			&i.Description,
			&i.LifecycleStatus,
			&i.ReplacementUrl,
			&i.Url,
			&i.ManufacturerCode,
			&i.SapCode,
			&i.TotalQuantity,
			&i.CreatedAt,
			&i.QuantityByArea,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchUniqueProductsPaginated = `-- name: SearchUniqueProductsPaginated :many
WITH product_aggregates AS (
    SELECT
        p.code,
        MIN(p.description) as description,
        MIN(p.lifecycle_status) as lifecycle_status,
        MIN(p.replacement_url) as replacement_url,
        MIN(p.url) as url,
        MIN(p.manufacturer_code) as manufacturer_code,
        MIN(p.sap_code) as sap_code,
        SUM(COALESCE(p.quantity, 0))::INTEGER as total_quantity,
        MIN(p.created_at) as created_at,
        json_agg(
            json_build_object(
                'area_id', p.area_id,
                'area_name', a.name,
                'quantity', COALESCE(p.quantity, 0)
            ) ORDER BY a.name
        ) FILTER (WHERE p.area_id IS NOT NULL) as quantity_by_area
    FROM products p
    LEFT JOIN areas a ON p.area_id = a.id
    GROUP BY p.code
)
SELECT code, description, lifecycle_status, replacement_url, url, manufacturer_code, sap_code, total_quantity, created_at, quantity_by_area FROM product_aggregates
WHERE code ILIKE '%' || $1::text || '%'
   OR description ILIKE '%' || $1::text || '%'
   OR sap_code ILIKE '%' || $1::text || '%'
   OR manufacturer_code ILIKE '%' || $1::text || '%'
   OR lifecycle_status ILIKE '%' || $1::text || '%'
ORDER BY lifecycle_status DESC, created_at DESC
LIMIT $3 OFFSET $2
`

type SearchUniqueProductsPaginatedParams struct {
	Search string `json:"search"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

type SearchUniqueProductsPaginatedRow struct {
	Code             string      `json:"code"`
	Description      interface{} `json:"description"`
	LifecycleStatus  interface{} `json:"lifecycle_status"`
	ReplacementUrl   interface{} `json:"replacement_url"`
	Url              interface{} `json:"url"`
	ManufacturerCode interface{} `json:"manufacturer_code"`
	SapCode          interface{} `json:"sap_code"`
	TotalQuantity    int32       `json:"total_quantity"`
	CreatedAt        interface{} `json:"created_at"`
	QuantityByArea   []byte      `json:"quantity_by_area"`
}

func (q *Queries) SearchUniqueProductsPaginated(ctx context.Context, arg SearchUniqueProductsPaginatedParams) ([]SearchUniqueProductsPaginatedRow, error) {
	rows, err := q.db.Query(ctx, searchUniqueProductsPaginated, arg.Search, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchUniqueProductsPaginatedRow
	for rows.Next() {
		var i SearchUniqueProductsPaginatedRow
		if err := rows.Scan(
			&i.Code,
			&i.Description,
			&i.LifecycleStatus,
			&i.ReplacementUrl,
			&i.Url,
			&i.ManufacturerCode,
			&i.SapCode,
			&i.TotalQuantity,
			&i.CreatedAt,
			&i.QuantityByArea,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE products
SET
    code = COALESCE($1, code),
    url = COALESCE($2, url),
    area_id = COALESCE($3, area_id),
    description = COALESCE($4, description),
    manufacturer_code = COALESCE($5, manufacturer_code),
    quantity = COALESCE($6, quantity),
    sap_code = COALESCE($7, sap_code),
    observations = COALESCE($8, observations),
    min_quantity = COALESCE($9, min_quantity),
    max_quantity = COALESCE($10, max_quantity),
    inventory_status = COALESCE($11, inventory_status)
WHERE id = $12
RETURNING id, code, url, area_id, description, manufacturer_code, quantity, replacement_url, sap_code, observations, min_quantity, max_quantity, inventory_status, lifecycle_status, created_at
`

type UpdateProductParams struct {
	Code             pgtype.Text `json:"code"`
	Url              pgtype.Text `json:"url"`
	AreaID           pgtype.UUID `json:"area_id"`
	Description      pgtype.Text `json:"description"`
	ManufacturerCode pgtype.Text `json:"manufacturer_code"`
	Quantity         pgtype.Int4 `json:"quantity"`
	SapCode          pgtype.Text `json:"sap_code"`
	Observations     pgtype.Text `json:"observations"`
	MinQuantity      pgtype.Int4 `json:"min_quantity"`
	MaxQuantity      pgtype.Int4 `json:"max_quantity"`
	InventoryStatus  pgtype.Text `json:"inventory_status"`
	ID               pgtype.UUID `json:"id"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, updateProduct,
		arg.Code,
		arg.Url,
		arg.AreaID,
		arg.Description,
		arg.ManufacturerCode,
		arg.Quantity,
		arg.SapCode,
		arg.Observations,
		arg.MinQuantity,
		arg.MaxQuantity,
		arg.InventoryStatus,
		arg.ID,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Url,
		&i.AreaID,
		&i.Description,
		&i.ManufacturerCode,
		&i.Quantity,
		&i.ReplacementUrl,
		&i.SapCode,
		&i.Observations,
		&i.MinQuantity,
		&i.MaxQuantity,
		&i.InventoryStatus,
		&i.LifecycleStatus,
		&i.CreatedAt,
	)
	return i, err
}

const updateProductLifecycleStatus = `-- name: UpdateProductLifecycleStatus :exec
UPDATE products
SET
    lifecycle_status = COALESCE($1, lifecycle_status),
    replacement_url = COALESCE($2, replacement_url)
WHERE code = $3
`

type UpdateProductLifecycleStatusParams struct {
	LifecycleStatus pgtype.Text `json:"lifecycle_status"`
	ReplacementUrl  pgtype.Text `json:"replacement_url"`
	Code            string      `json:"code"`
}

func (q *Queries) UpdateProductLifecycleStatus(ctx context.Context, arg UpdateProductLifecycleStatusParams) error {
	_, err := q.db.Exec(ctx, updateProductLifecycleStatus, arg.LifecycleStatus, arg.ReplacementUrl, arg.Code)
	return err
}
